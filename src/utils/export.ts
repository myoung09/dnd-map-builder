// Export utilities for PNG, SVG, and JSON

import { MapData } from '../types/generator';

export class ExportUtils {
  static exportMapToPNG(canvas: HTMLCanvasElement, filename: string = 'map.png'): void {
    const dataUrl = canvas.toDataURL('image/png');
    const link = document.createElement('a');
    link.download = filename;
    link.href = dataUrl;
    link.click();
  }

  /**
   * Export map as SVG for scalable vector graphics (perfect for printing)
   * Converts the grid-based map data into an SVG document
   */
  static exportMapToSVG(mapData: MapData, cellSize: number, filename: string = 'map.svg'): void {
    const width = mapData.width * cellSize;
    const height = mapData.height * cellSize;
    
    // Create SVG document
    let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
  <title>${mapData.terrainType} Map - Seed: ${mapData.seed}</title>
  <desc>Generated by DnD Map Builder</desc>
  
  <!-- Background -->
  <rect width="${width}" height="${height}" fill="#f5f5dc"/>
  
  <!-- Grid -->
  <g id="grid" opacity="0.3" stroke="#999" stroke-width="0.5">`;
    
    // Draw grid lines
    for (let x = 0; x <= mapData.width; x++) {
      svg += `\n    <line x1="${x * cellSize}" y1="0" x2="${x * cellSize}" y2="${height}"/>`;
    }
    for (let y = 0; y <= mapData.height; y++) {
      svg += `\n    <line x1="0" y1="${y * cellSize}" x2="${width}" y2="${y * cellSize}"/>`;
    }
    
    svg += `\n  </g>\n\n  <!-- Map Content -->\n  <g id="map">`;
    
    // Draw based on grid data
    if (mapData.grid) {
      for (let y = 0; y < mapData.height; y++) {
        for (let x = 0; x < mapData.width; x++) {
          const cell = mapData.grid[y][x];
          const px = x * cellSize;
          const py = y * cellSize;
          
          if (cell === 0) {
            // Floor - light color
            svg += `\n    <rect x="${px}" y="${py}" width="${cellSize}" height="${cellSize}" fill="#8b7355" stroke="none"/>`;
          } else if (cell === 1) {
            // Wall - dark color
            svg += `\n    <rect x="${px}" y="${py}" width="${cellSize}" height="${cellSize}" fill="#333" stroke="none"/>`;
          } else if (cell === 2) {
            // Path - special color
            svg += `\n    <rect x="${px}" y="${py}" width="${cellSize}" height="${cellSize}" fill="#9a8066" stroke="none"/>`;
          }
        }
      }
    }
    
    // Draw rooms with borders
    if (mapData.rooms) {
      svg += `\n    <!-- Rooms -->`;
      for (const room of mapData.rooms) {
        svg += `\n    <rect x="${room.x * cellSize}" y="${room.y * cellSize}" width="${room.width * cellSize}" height="${room.height * cellSize}" fill="none" stroke="#6a5a45" stroke-width="2"/>`;
      }
    }
    
    // Draw trees as circles
    if (mapData.trees) {
      svg += `\n    <!-- Trees -->`;
      for (const tree of mapData.trees) {
        const cx = tree.x * cellSize;
        const cy = tree.y * cellSize;
        const r = (tree.size || 2.5) * cellSize;
        svg += `\n    <circle cx="${cx}" cy="${cy}" r="${r}" fill="#2d5016" opacity="0.8"/>`;
      }
    }
    
    svg += `\n  </g>\n</svg>`;
    
    // Download SVG
    const blob = new Blob([svg], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.download = filename;
    link.href = url;
    link.click();
    URL.revokeObjectURL(url);
  }

  static exportMapToJSON(mapData: MapData, filename: string = 'map.json'): void {
    const jsonString = JSON.stringify(mapData, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.download = filename;
    link.href = url;
    link.click();
    
    URL.revokeObjectURL(url);
  }

  static importMapFromJSON(file: File): Promise<MapData> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = (e) => {
        try {
          const result = e.target?.result;
          if (typeof result === 'string') {
            const mapData = JSON.parse(result) as MapData;
            resolve(mapData);
          } else {
            reject(new Error('Invalid file content'));
          }
        } catch (error) {
          reject(error);
        }
      };
      
      reader.onerror = () => reject(reader.error);
      reader.readAsText(file);
    });
  }

  static downloadCombinedExport(
    mapData: MapData,
    canvasDataUrl: string,
    baseName: string = 'map'
  ): void {
    // Download JSON
    this.exportMapToJSON(mapData, `${baseName}.json`);
    
    // Download PNG
    const link = document.createElement('a');
    link.download = `${baseName}.png`;
    link.href = canvasDataUrl;
    link.click();
  }
}
